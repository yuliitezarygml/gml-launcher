# GML Auth Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Go HTTP server с кастомной аутентификацией для GML Launcher, JSON база данных, admin REST API.

**Architecture:** Один HTTP сервер на порту 5003. Два роутера — публичный `/api/v1/integrations/auth/signin` для GML Launcher и `/admin/users` для управления пользователями. JSON файл как база данных с атомарной записью.

**Tech Stack:** Go 1.21+, stdlib only (`net/http`, `encoding/json`, `sync`, `github.com/google/uuid` для UUID генерации).

---

### Task 1: Инициализация Go модуля

**Files:**
- Create: `gml-auth/go.mod`
- Create: `gml-auth/data/users.json`

**Step 1: Инициализировать модуль**

```bash
cd /c/Users/yuliitezary/gml-auth
go mod init gml-auth
```

Expected: создан `go.mod` с `module gml-auth`

**Step 2: Добавить UUID зависимость**

```bash
go get github.com/google/uuid
```

**Step 3: Создать начальный файл базы данных**

Создать `data/users.json`:
```json
{
  "users": [
    {
      "uuid": "c07a9841-2275-4ba0-8f1c-2e1599a1f22f",
      "login": "admin",
      "password": "admin123",
      "is_slim": false,
      "blocked": false,
      "block_reason": ""
    }
  ]
}
```

**Step 4: Commit**

```bash
git init
git add go.mod go.sum data/users.json
git commit -m "chore: init go module and seed database"
```

---

### Task 2: Модели данных

**Files:**
- Create: `models/user.go`

**Step 1: Написать тест**

Создать `models/user_test.go`:
```go
package models

import (
    "encoding/json"
    "testing"
)

func TestUserSerialization(t *testing.T) {
    u := User{
        UUID:        "test-uuid",
        Login:       "testuser",
        Password:    "pass",
        IsSlim:      false,
        Blocked:     false,
        BlockReason: "",
    }
    data, err := json.Marshal(u)
    if err != nil {
        t.Fatal(err)
    }
    var u2 User
    if err := json.Unmarshal(data, &u2); err != nil {
        t.Fatal(err)
    }
    if u2.Login != "testuser" {
        t.Errorf("expected testuser, got %s", u2.Login)
    }
}
```

**Step 2: Запустить тест — должен упасть**

```bash
go test ./models/...
```

Expected: FAIL — `User` не определён

**Step 3: Реализовать модели**

Создать `models/user.go`:
```go
package models

// User — запись пользователя в JSON базе данных
type User struct {
    UUID        string `json:"uuid"`
    Login       string `json:"login"`
    Password    string `json:"password"`
    IsSlim      bool   `json:"is_slim"`
    Blocked     bool   `json:"blocked"`
    BlockReason string `json:"block_reason"`
}

// Database — структура JSON файла
type Database struct {
    Users []User `json:"users"`
}

// AuthRequest — запрос от GML Launcher
type AuthRequest struct {
    Login    string `json:"Login"`
    Password string `json:"Password"`
    Totp     string `json:"Totp"`
}

// AuthResponse — ответ при успешной авторизации (200)
type AuthResponse struct {
    Login    string `json:"Login"`
    UserUuid string `json:"UserUuid"`
    IsSlim   bool   `json:"IsSlim"`
    Message  string `json:"Message"`
}

// ErrorResponse — ответ при ошибке (401, 403, 404)
type ErrorResponse struct {
    Message string `json:"Message"`
}

// CreateUserRequest — запрос для создания пользователя через admin API
type CreateUserRequest struct {
    Login    string `json:"login"`
    Password string `json:"password"`
    IsSlim   bool   `json:"is_slim"`
}

// BlockRequest — запрос для блокировки пользователя
type BlockRequest struct {
    Reason string `json:"reason"`
}
```

**Step 4: Запустить тест — должен пройти**

```bash
go test ./models/...
```

Expected: PASS

**Step 5: Commit**

```bash
git add models/
git commit -m "feat: add data models"
```

---

### Task 3: JSON хранилище

**Files:**
- Create: `storage/storage.go`
- Create: `storage/storage_test.go`

**Step 1: Написать тесты**

Создать `storage/storage_test.go`:
```go
package storage

import (
    "gml-auth/models"
    "os"
    "testing"
)

func TestLoadSave(t *testing.T) {
    // временный файл
    f, err := os.CreateTemp("", "test-*.json")
    if err != nil {
        t.Fatal(err)
    }
    f.WriteString(`{"users":[]}`)
    f.Close()
    defer os.Remove(f.Name())

    s := New(f.Name())

    // добавить пользователя
    user := models.User{UUID: "uuid-1", Login: "test", Password: "pass"}
    if err := s.AddUser(user); err != nil {
        t.Fatal(err)
    }

    // найти пользователя
    found, err := s.FindByLogin("test")
    if err != nil {
        t.Fatal(err)
    }
    if found.UUID != "uuid-1" {
        t.Errorf("expected uuid-1, got %s", found.UUID)
    }
}

func TestFindNotFound(t *testing.T) {
    f, _ := os.CreateTemp("", "test-*.json")
    f.WriteString(`{"users":[]}`)
    f.Close()
    defer os.Remove(f.Name())

    s := New(f.Name())
    _, err := s.FindByLogin("nobody")
    if err == nil {
        t.Error("expected error for missing user")
    }
}
```

**Step 2: Запустить тест — должен упасть**

```bash
go test ./storage/...
```

Expected: FAIL

**Step 3: Реализовать хранилище**

Создать `storage/storage.go`:
```go
package storage

import (
    "encoding/json"
    "errors"
    "gml-auth/models"
    "os"
    "sync"
)

var ErrNotFound = errors.New("user not found")

type Storage struct {
    mu       sync.RWMutex
    filePath string
}

func New(filePath string) *Storage {
    return &Storage{filePath: filePath}
}

func (s *Storage) load() (models.Database, error) {
    data, err := os.ReadFile(s.filePath)
    if err != nil {
        return models.Database{}, err
    }
    var db models.Database
    return db, json.Unmarshal(data, &db)
}

func (s *Storage) save(db models.Database) error {
    data, err := json.MarshalIndent(db, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(s.filePath, data, 0644)
}

func (s *Storage) FindByLogin(login string) (models.User, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    db, err := s.load()
    if err != nil {
        return models.User{}, err
    }
    for _, u := range db.Users {
        if u.Login == login {
            return u, nil
        }
    }
    return models.User{}, ErrNotFound
}

func (s *Storage) ListUsers() ([]models.User, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    db, err := s.load()
    if err != nil {
        return nil, err
    }
    return db.Users, nil
}

func (s *Storage) AddUser(user models.User) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    db, err := s.load()
    if err != nil {
        return err
    }
    db.Users = append(db.Users, user)
    return s.save(db)
}

func (s *Storage) DeleteUser(login string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    db, err := s.load()
    if err != nil {
        return err
    }
    filtered := db.Users[:0]
    for _, u := range db.Users {
        if u.Login != login {
            filtered = append(filtered, u)
        }
    }
    if len(filtered) == len(db.Users) {
        return ErrNotFound
    }
    db.Users = filtered
    return s.save(db)
}

func (s *Storage) UpdateUser(login string, fn func(*models.User)) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    db, err := s.load()
    if err != nil {
        return err
    }
    found := false
    for i := range db.Users {
        if db.Users[i].Login == login {
            fn(&db.Users[i])
            found = true
            break
        }
    }
    if !found {
        return ErrNotFound
    }
    return s.save(db)
}
```

**Step 4: Запустить тест — должен пройти**

```bash
go test ./storage/...
```

Expected: PASS

**Step 5: Commit**

```bash
git add storage/
git commit -m "feat: add json storage layer"
```

---

### Task 4: Auth handler

**Files:**
- Create: `handlers/auth.go`

**Step 1: Написать тест**

Создать `handlers/auth_test.go`:
```go
package handlers

import (
    "bytes"
    "gml-auth/models"
    "gml-auth/storage"
    "net/http"
    "net/http/httptest"
    "os"
    "strings"
    "testing"
)

func setupStorage(t *testing.T) *storage.Storage {
    f, _ := os.CreateTemp("", "test-*.json")
    f.WriteString(`{"users":[]}`)
    f.Close()
    t.Cleanup(func() { os.Remove(f.Name()) })
    s := storage.New(f.Name())
    s.AddUser(models.User{
        UUID: "uuid-1", Login: "GamerVII", Password: "pass123",
        IsSlim: false, Blocked: false,
    })
    s.AddUser(models.User{
        UUID: "uuid-2", Login: "banned", Password: "pass",
        Blocked: true, BlockReason: "читерство",
    })
    return s
}

func TestAuthSuccess(t *testing.T) {
    s := setupStorage(t)
    h := NewAuthHandler(s)
    body := `{"Login":"GamerVII","Password":"pass123","Totp":""}`
    req := httptest.NewRequest(http.MethodPost, "/api/v1/integrations/auth/signin", bytes.NewBufferString(body))
    w := httptest.NewRecorder()
    h.SignIn(w, req)
    if w.Code != http.StatusOK {
        t.Errorf("expected 200, got %d: %s", w.Code, w.Body.String())
    }
    if !strings.Contains(w.Body.String(), "GamerVII") {
        t.Errorf("expected login in response: %s", w.Body.String())
    }
}

func TestAuthWrongPassword(t *testing.T) {
    s := setupStorage(t)
    h := NewAuthHandler(s)
    body := `{"Login":"GamerVII","Password":"wrong","Totp":""}`
    req := httptest.NewRequest(http.MethodPost, "/api/v1/integrations/auth/signin", bytes.NewBufferString(body))
    w := httptest.NewRecorder()
    h.SignIn(w, req)
    if w.Code != http.StatusUnauthorized {
        t.Errorf("expected 401, got %d", w.Code)
    }
}

func TestAuthNotFound(t *testing.T) {
    s := setupStorage(t)
    h := NewAuthHandler(s)
    body := `{"Login":"nobody","Password":"pass","Totp":""}`
    req := httptest.NewRequest(http.MethodPost, "/api/v1/integrations/auth/signin", bytes.NewBufferString(body))
    w := httptest.NewRecorder()
    h.SignIn(w, req)
    if w.Code != http.StatusNotFound {
        t.Errorf("expected 404, got %d", w.Code)
    }
}

func TestAuthBlocked(t *testing.T) {
    s := setupStorage(t)
    h := NewAuthHandler(s)
    body := `{"Login":"banned","Password":"pass","Totp":""}`
    req := httptest.NewRequest(http.MethodPost, "/api/v1/integrations/auth/signin", bytes.NewBufferString(body))
    w := httptest.NewRecorder()
    h.SignIn(w, req)
    if w.Code != http.StatusForbidden {
        t.Errorf("expected 403, got %d", w.Code)
    }
}
```

**Step 2: Запустить тест — должен упасть**

```bash
go test ./handlers/...
```

Expected: FAIL

**Step 3: Реализовать auth handler**

Создать `handlers/auth.go`:
```go
package handlers

import (
    "encoding/json"
    "errors"
    "fmt"
    "gml-auth/models"
    "gml-auth/storage"
    "net/http"
)

type AuthHandler struct {
    store *storage.Storage
}

func NewAuthHandler(store *storage.Storage) *AuthHandler {
    return &AuthHandler{store: store}
}

func writeJSON(w http.ResponseWriter, code int, v any) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    json.NewEncoder(w).Encode(v)
}

func (h *AuthHandler) SignIn(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        return
    }

    var req models.AuthRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSON(w, http.StatusBadRequest, models.ErrorResponse{Message: "Неверный формат запроса"})
        return
    }

    user, err := h.store.FindByLogin(req.Login)
    if errors.Is(err, storage.ErrNotFound) {
        writeJSON(w, http.StatusNotFound, models.ErrorResponse{Message: "Пользователь не найден"})
        return
    }
    if err != nil {
        writeJSON(w, http.StatusInternalServerError, models.ErrorResponse{Message: "Ошибка сервера"})
        return
    }

    if user.Blocked {
        msg := fmt.Sprintf("Пользователь заблокирован. Причина: %s", user.BlockReason)
        writeJSON(w, http.StatusForbidden, models.ErrorResponse{Message: msg})
        return
    }

    if user.Password != req.Password {
        writeJSON(w, http.StatusUnauthorized, models.ErrorResponse{Message: "Неверный логин или пароль"})
        return
    }

    writeJSON(w, http.StatusOK, models.AuthResponse{
        Login:    user.Login,
        UserUuid: user.UUID,
        IsSlim:   user.IsSlim,
        Message:  "Успешная авторизация",
    })
}
```

**Step 4: Запустить тест — должен пройти**

```bash
go test ./handlers/...
```

Expected: PASS

**Step 5: Commit**

```bash
git add handlers/auth.go handlers/auth_test.go
git commit -m "feat: add auth handler"
```

---

### Task 5: Admin handler

**Files:**
- Create: `handlers/admin.go`

**Step 1: Реализовать admin handler**

Создать `handlers/admin.go`:
```go
package handlers

import (
    "encoding/json"
    "errors"
    "gml-auth/models"
    "gml-auth/storage"
    "net/http"
    "strings"

    "github.com/google/uuid"
)

type AdminHandler struct {
    store *storage.Storage
}

func NewAdminHandler(store *storage.Storage) *AdminHandler {
    return &AdminHandler{store: store}
}

// loginFromPath извлекает {login} из пути вида /admin/users/{login}[/action]
func loginFromPath(path string) string {
    parts := strings.Split(strings.Trim(path, "/"), "/")
    // /admin/users/{login} → ["admin","users","{login}"]
    if len(parts) >= 3 {
        return parts[2]
    }
    return ""
}

func (h *AdminHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    path := r.URL.Path // /admin/users, /admin/users/foo, /admin/users/foo/block

    switch {
    case path == "/admin/users" && r.Method == http.MethodGet:
        h.listUsers(w, r)
    case path == "/admin/users" && r.Method == http.MethodPost:
        h.createUser(w, r)
    case strings.HasSuffix(path, "/block") && r.Method == http.MethodPatch:
        login := loginFromPath(strings.TrimSuffix(path, "/block"))
        h.blockUser(w, r, login)
    case strings.HasSuffix(path, "/unblock") && r.Method == http.MethodPatch:
        login := loginFromPath(strings.TrimSuffix(path, "/unblock"))
        h.unblockUser(w, r, login)
    case r.Method == http.MethodDelete:
        login := loginFromPath(path)
        h.deleteUser(w, r, login)
    default:
        w.WriteHeader(http.StatusNotFound)
    }
}

func (h *AdminHandler) listUsers(w http.ResponseWriter, _ *http.Request) {
    users, err := h.store.ListUsers()
    if err != nil {
        writeJSON(w, http.StatusInternalServerError, models.ErrorResponse{Message: "Ошибка чтения"})
        return
    }
    writeJSON(w, http.StatusOK, users)
}

func (h *AdminHandler) createUser(w http.ResponseWriter, r *http.Request) {
    var req models.CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.Login == "" || req.Password == "" {
        writeJSON(w, http.StatusBadRequest, models.ErrorResponse{Message: "Нужны login и password"})
        return
    }
    user := models.User{
        UUID:     uuid.New().String(),
        Login:    req.Login,
        Password: req.Password,
        IsSlim:   req.IsSlim,
    }
    if err := h.store.AddUser(user); err != nil {
        writeJSON(w, http.StatusInternalServerError, models.ErrorResponse{Message: "Ошибка создания"})
        return
    }
    writeJSON(w, http.StatusCreated, user)
}

func (h *AdminHandler) deleteUser(w http.ResponseWriter, _ *http.Request, login string) {
    if login == "" {
        writeJSON(w, http.StatusBadRequest, models.ErrorResponse{Message: "Нужен login"})
        return
    }
    err := h.store.DeleteUser(login)
    if errors.Is(err, storage.ErrNotFound) {
        writeJSON(w, http.StatusNotFound, models.ErrorResponse{Message: "Пользователь не найден"})
        return
    }
    w.WriteHeader(http.StatusNoContent)
}

func (h *AdminHandler) blockUser(w http.ResponseWriter, r *http.Request, login string) {
    if login == "" {
        writeJSON(w, http.StatusBadRequest, models.ErrorResponse{Message: "Нужен login"})
        return
    }
    var req models.BlockRequest
    json.NewDecoder(r.Body).Decode(&req)

    err := h.store.UpdateUser(login, func(u *models.User) {
        u.Blocked = true
        u.BlockReason = req.Reason
    })
    if errors.Is(err, storage.ErrNotFound) {
        writeJSON(w, http.StatusNotFound, models.ErrorResponse{Message: "Пользователь не найден"})
        return
    }
    writeJSON(w, http.StatusOK, models.ErrorResponse{Message: "Заблокирован"})
}

func (h *AdminHandler) unblockUser(w http.ResponseWriter, _ *http.Request, login string) {
    if login == "" {
        writeJSON(w, http.StatusBadRequest, models.ErrorResponse{Message: "Нужен login"})
        return
    }
    err := h.store.UpdateUser(login, func(u *models.User) {
        u.Blocked = false
        u.BlockReason = ""
    })
    if errors.Is(err, storage.ErrNotFound) {
        writeJSON(w, http.StatusNotFound, models.ErrorResponse{Message: "Пользователь не найден"})
        return
    }
    writeJSON(w, http.StatusOK, models.ErrorResponse{Message: "Разблокирован"})
}
```

**Step 2: Commit**

```bash
git add handlers/admin.go
git commit -m "feat: add admin handler"
```

---

### Task 6: main.go — сборка сервера

**Files:**
- Create: `main.go`

**Step 1: Реализовать main.go**

```go
package main

import (
    "gml-auth/handlers"
    "gml-auth/storage"
    "log"
    "net/http"
)

func main() {
    store := storage.New("data/users.json")

    authHandler := handlers.NewAuthHandler(store)
    adminHandler := handlers.NewAdminHandler(store)

    mux := http.NewServeMux()

    // GML Launcher endpoint
    mux.HandleFunc("/api/v1/integrations/auth/signin", authHandler.SignIn)

    // Admin API
    mux.Handle("/admin/users", adminHandler)
    mux.Handle("/admin/users/", adminHandler)

    log.Println("GML Auth server started on :5003")
    log.Fatal(http.ListenAndServe(":5003", mux))
}
```

**Step 2: Собрать проект**

```bash
go build ./...
```

Expected: без ошибок

**Step 3: Запустить все тесты**

```bash
go test ./...
```

Expected: все PASS

**Step 4: Commit**

```bash
git add main.go
git commit -m "feat: add main server entrypoint"
```

---

### Task 7: Финальная проверка

**Step 1: Запустить сервер**

```bash
go run main.go
```

**Step 2: Проверить auth (в другом терминале)**

```bash
# Успешный вход
curl -X POST http://localhost:5003/api/v1/integrations/auth/signin \
  -H "Content-Type: application/json" \
  -d '{"Login":"admin","Password":"admin123","Totp":""}'
# Ожидание: 200 с UUID и логином

# Неверный пароль
curl -X POST http://localhost:5003/api/v1/integrations/auth/signin \
  -H "Content-Type: application/json" \
  -d '{"Login":"admin","Password":"wrong","Totp":""}'
# Ожидание: 401
```

**Step 3: Проверить admin API**

```bash
# Список пользователей
curl http://localhost:5003/admin/users

# Создать пользователя
curl -X POST http://localhost:5003/admin/users \
  -H "Content-Type: application/json" \
  -d '{"login":"player1","password":"pass123","is_slim":false}'

# Заблокировать
curl -X PATCH http://localhost:5003/admin/users/player1/block \
  -H "Content-Type: application/json" \
  -d '{"reason":"читерство"}'

# Разблокировать
curl -X PATCH http://localhost:5003/admin/users/player1/unblock

# Удалить
curl -X DELETE http://localhost:5003/admin/users/player1
```

**Step 4: Финальный commit**

```bash
git add .
git commit -m "docs: add implementation plan"
```
